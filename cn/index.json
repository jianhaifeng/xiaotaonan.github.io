[{"content":"1.分代ZGC 是否在openjdk的21版本里面完全实现？还是部分实现？ 完全实现\n2.分代ZGC和普通的ZGC的主要区别在哪里？ 普通的ZGC：每次回收所有对象 分代ZGC：分代进行回收 我们相信，Generational ZGC 将比其前身更适合大多数用例。 由于资源使用率较低，某些工作负载甚至可能会通过分代 ZGC 获得吞吐量提升。 例如，当运行 Apache Cassandra 基准测试时，与非分代 ZGC 相比，分代 ZGC 需要四分之一的堆大小，但却实现了四倍的吞吐量，同时仍将暂停时间保持在一毫秒以下。\n某些工作负载本质上是非分代的，并且可能会出现轻微的性能下降。 我们认为，这是一组足够小的工作负载，不足以证明长期维护两个单独版本的 ZGC 的成本是合理的。\n另一种开销来源是功能更强大的 GC 屏障。 我们预计其中大部分将被不必频繁收集老一代对象的收益所抵消。\n另一个额外的开销来源是同时运行两个垃圾收集器。 我们需要确保平衡它们的调用率和 CPU 消耗，以便它们不会过度影响应用程序。\n正如 GC 开发的正常情况一样，未来的改进和优化将由基准测试和用户反馈驱动。 即使在第一个版本发布之后，我们也打算继续改进 Generational ZGC。\n3.分代ZGC在OpenJDK的开发过程中，他们开发的时间跨度，研发人员等等信息。主要目的是希望能对这个工作的大概effort有一个评估。 3.1.JDK21-日程 Schedule 2023/06/08\tRampdown Phase One (fork from main line-JDK17-LTS) 2023/07/20\tRampdown Phase Two 2023/08/10\tInitial Release Candidate 2023/08/24\tFinal Release Candidate 2023/09/19\tGeneral Availability Amost 103days\n3.2.分代ZGC-研发人员 Co-authored-by: Stefan Karlsson Co-authored-by: Erik Österlund Co-authored-by: Axel Boldt-Christmas Co-authored-by: Per Liden Co-authored-by: Stefan Johansson Co-authored-by: Albert Mingkun Yang Co-authored-by: Erik Helin Co-authored-by: Roberto Castañeda Lozano Co-authored-by: Nils Eliasson Co-authored-by: Martin Doerr Co-authored-by: Leslie Zhai Co-authored-by: Fei Yang Co-authored-by: Yadong Wang Reviewed-by: eosterlund, aboldtch, rcastanedalo 13人\n3.3.分代ZGC-工作量 3.3.1.功能范围 JEPS439\n非多重映射内存\n屏障优化\n2. 1.快路径和慢路径\n2. 2.最大限度地减少负载屏障的责任\n2. 3.双缓冲记忆集\n2. 4.记忆设置的屏障\n2. 5.SATB 标记屏障\n2. 6.融合存储屏障检查\n2. 7.存储屏障缓冲区\n2. 8.修补屏障\n无需额外堆内存的重定位\n密集堆区\n大对象\n完整的垃圾收集\n3.3.2.代码量 Showing 667 changed files with 63,137 additions and 7,698 deletions.\n4.Backport这个功能到java17的可行性？ 4.1.吞吐量 就吞吐量而言，分代 ZGC 比 JDK 17 中的单代 ZGC 提高了约 10%，比 JDK 21 中的单代 ZGC 提高了 10% 多一点，而 JDK 21 中的单代 ZGC 略有下降。\n4.2.延迟 与单代 ZGC 相比，分代 ZGC 的平均延迟略有下降。\n当考虑最大暂停时间时，ZGC 开始表现出色。下图显示 P99 暂停时间提高了 10-20%。\n分代ZGC最大的优势是，它显著降低了单代ZGC所存在的最大问题——分配停滞的可能性。分配停滞是指新对象分配的速率快于ZGC回收内存的速率。\n5.验证场景 5.1.多客户端并发 如果我们将用例切换到ApacheCassandra并查看99.999%，就可以看出这个问题。下图显示，多达75个并发客户端，单代ZGC和多代ZGC具有相似的性能。然而，超过75个并发客户端，单代ZGC会不堪重负，并遇到分配停滞问题。另一方面，Generational ZGC没有遇到这种情况，即使有多达275个并发客户端，也能保持一致的暂停时间。\n5.2.P99.99 Event 要求99.99% 的请求应该比给定的延迟更快。换句话说，只允许 0.01% 的请求变慢。与旧的运行非常相似，单代ZGC在低负载下表现非常好，但随着分配压力的增加，更糟糕的延迟也会增加。对于Generational ZGC，情况已不再如此。即使在高负载下，p99.99延迟也非常低。\n","permalink":"https://xiaotaonan.github.io/cn/posts/generational-zgc/","summary":"1.分代ZGC 是否在openjdk的21版本里面完全实现？还是部分实现？ 完全实现\n2.分代ZGC和普通的ZGC的主要区别在哪里？ 普通的ZGC：每次回收所有对象 分代ZGC：分代进行回收 我们相信，Generational ZGC 将比其前身更适合大多数用例。 由于资源使用率较低，某些工作负载甚至可能会通过分代 ZGC 获得吞吐量提升。 例如，当运行 Apache Cassandra 基准测试时，与非分代 ZGC 相比，分代 ZGC 需要四分之一的堆大小，但却实现了四倍的吞吐量，同时仍将暂停时间保持在一毫秒以下。\n某些工作负载本质上是非分代的，并且可能会出现轻微的性能下降。 我们认为，这是一组足够小的工作负载，不足以证明长期维护两个单独版本的 ZGC 的成本是合理的。\n另一种开销来源是功能更强大的 GC 屏障。 我们预计其中大部分将被不必频繁收集老一代对象的收益所抵消。\n另一个额外的开销来源是同时运行两个垃圾收集器。 我们需要确保平衡它们的调用率和 CPU 消耗，以便它们不会过度影响应用程序。\n正如 GC 开发的正常情况一样，未来的改进和优化将由基准测试和用户反馈驱动。 即使在第一个版本发布之后，我们也打算继续改进 Generational ZGC。\n3.分代ZGC在OpenJDK的开发过程中，他们开发的时间跨度，研发人员等等信息。主要目的是希望能对这个工作的大概effort有一个评估。 3.1.JDK21-日程 Schedule 2023/06/08\tRampdown Phase One (fork from main line-JDK17-LTS) 2023/07/20\tRampdown Phase Two 2023/08/10\tInitial Release Candidate 2023/08/24\tFinal Release Candidate 2023/09/19\tGeneral Availability Amost 103days\n3.2.分代ZGC-研发人员 Co-authored-by: Stefan Karlsson Co-authored-by: Erik Österlund Co-authored-by: Axel Boldt-Christmas Co-authored-by: Per Liden Co-authored-by: Stefan Johansson Co-authored-by: Albert Mingkun Yang Co-authored-by: Erik Helin Co-authored-by: Roberto Castañeda Lozano Co-authored-by: Nils Eliasson Co-authored-by: Martin Doerr Co-authored-by: Leslie Zhai Co-authored-by: Fei Yang Co-authored-by: Yadong Wang Reviewed-by: eosterlund, aboldtch, rcastanedalo 13人","title":"分代ZGC"},{"content":"1.对比测试 1.1.测试环境 笔记本（3.1 GHz Intel Core i5, 4Gb RAM and 50Gb SSD.）\n操作系统内核（3.10.0-1160.102.1.el7.x86_64）\n操作系统（CentOS:7.9 VM）\n平台: x86_64\nVM Parameters：除存放和加载镜像日志的参数外，没使用其它参数\n2.测试场景 2.1.场景一：Time Of First Operation 2.1.1.问题1：为什么Azul Prime ReadyNow相对于CRaC第二次启动会出现加速幅度降低？ 2.2.场景二：Time To Complete 100000 Operations 2.2.1.问题2：为什么Azul Prime ReadyNow相对于CRaC在100000笔请求延迟降低会比CRaC好？ 3.补充材料 3.1.CRaC是Azul主导贡献到OpenJDK社区的 常理上讲，Azul Prime ReadyNow作为Azul商业收费版应该比开源CRaC更好。\n3.1.1.问题3：Azul Prime ReadyNow的安装包是不是正确的？ 3.1.2.问题4：验证所使用的用例是不是正确的？ 4.问题分析 4.1.问题1：为什么Azul Prime ReadyNow相对于CRaC第二次启动会出现加速幅度降低？ 4.1.1.猜测：串/并行文件处理导致的 4.1.1.1.CRaC用于恢复的文件结构-多文件组成 4.1.1.1.1.第一次启动截图-2.762秒完成启动 4.1.1.1.2.第二次启动截图-进程级恢复（进程ID一致） 4.1.1.2.ReadyNow用于恢复的文件结构-单文件组成 4.1.1.2.1.第一次启动截图-4.678秒完成启动 4.1.1.2.2.第二次启动截图-RootAC(提速16.2%)、APP（提速64.9%） 4.1.1.3.总结 1.单从文件加载效率角度分析，并行文件加载应该比串行文件处理效率高\n2.借鉴ReadyNow的方案时，可将用于恢复的文件分割为多文件进行处理，验证是否可进一步优化第二次启动时间？[a.下一步可考虑的工作]\n4.2.问题2：为什么Azul Prime ReadyNow相对于CRaC在100000笔请求延迟降低会比CRaC好？ 4.2.1.ReadyNow有JVM优化-Falcon JIT Compiler，而CRaC本质上没有优化JVM 4.2.1.1.CRaC-Hotspot VM CRaC本身没有优化JVM。\n4.2.1.2.ReadyNow-Zing VM 将C2替换为Azul自研的Falcon JIT Compiler。\n4.2.2.总结 1.可以被Zing VM的Falcon JIT Compiler直接编译的profile是什么？[b.下一步可考虑的工作]\n2.可以考虑使用Graal替代Hotspot VM中的C2，验证请求延迟是否会进一步降低？[c.下一步可考虑的工作]\n4.3.问题3：Azul Prime ReadyNow的安装包是不是正确的？ 4.3.1.当前下载地址 Azul Prime\n4.4.问题4：验证所使用的用例是不是正确的？ 4.4.1.当前所使用的测试用例-微服务框架 spring-boot-3.2.0\nmicronaut-3.8.7\nquarkus-2.16.5.Final\n","permalink":"https://xiaotaonan.github.io/cn/posts/readynow-crac/","summary":"1.对比测试 1.1.测试环境 笔记本（3.1 GHz Intel Core i5, 4Gb RAM and 50Gb SSD.）\n操作系统内核（3.10.0-1160.102.1.el7.x86_64）\n操作系统（CentOS:7.9 VM）\n平台: x86_64\nVM Parameters：除存放和加载镜像日志的参数外，没使用其它参数\n2.测试场景 2.1.场景一：Time Of First Operation 2.1.1.问题1：为什么Azul Prime ReadyNow相对于CRaC第二次启动会出现加速幅度降低？ 2.2.场景二：Time To Complete 100000 Operations 2.2.1.问题2：为什么Azul Prime ReadyNow相对于CRaC在100000笔请求延迟降低会比CRaC好？ 3.补充材料 3.1.CRaC是Azul主导贡献到OpenJDK社区的 常理上讲，Azul Prime ReadyNow作为Azul商业收费版应该比开源CRaC更好。\n3.1.1.问题3：Azul Prime ReadyNow的安装包是不是正确的？ 3.1.2.问题4：验证所使用的用例是不是正确的？ 4.问题分析 4.1.问题1：为什么Azul Prime ReadyNow相对于CRaC第二次启动会出现加速幅度降低？ 4.1.1.猜测：串/并行文件处理导致的 4.1.1.1.CRaC用于恢复的文件结构-多文件组成 4.1.1.1.1.第一次启动截图-2.762秒完成启动 4.1.1.1.2.第二次启动截图-进程级恢复（进程ID一致） 4.1.1.2.ReadyNow用于恢复的文件结构-单文件组成 4.1.1.2.1.第一次启动截图-4.678秒完成启动 4.1.1.2.2.第二次启动截图-RootAC(提速16.2%)、APP（提速64.9%） 4.1.1.3.总结 1.单从文件加载效率角度分析，并行文件加载应该比串行文件处理效率高\n2.借鉴ReadyNow的方案时，可将用于恢复的文件分割为多文件进行处理，验证是否可进一步优化第二次启动时间？[a.下一步可考虑的工作]\n4.2.问题2：为什么Azul Prime ReadyNow相对于CRaC在100000笔请求延迟降低会比CRaC好？ 4.2.1.ReadyNow有JVM优化-Falcon JIT Compiler，而CRaC本质上没有优化JVM 4.2.1.1.CRaC-Hotspot VM CRaC本身没有优化JVM。\n4.2.1.2.ReadyNow-Zing VM 将C2替换为Azul自研的Falcon JIT Compiler。","title":"ReadyNow和CRaC的对比"},{"content":"1.场景视图 2.逻辑视图 注：29个类，不包含C的源码\n3.开发视图 4.处理视图 4.1.启动应用 4.2.测试和调优 4.3.检查点生成 注：CRaC默认生成检查点镜像时会自动停止正在运行Java应用，但如Azul Prime ReadyNow、Spring-boot等支持按照周期等其它规则实现生成检查点镜像的同时不停止正在运行的Java应用，此功能也可用于生产环境。\n4.4.恢复 4.物理视图 略。\n","permalink":"https://xiaotaonan.github.io/cn/posts/crac41/","summary":"1.场景视图 2.逻辑视图 注：29个类，不包含C的源码\n3.开发视图 4.处理视图 4.1.启动应用 4.2.测试和调优 4.3.检查点生成 注：CRaC默认生成检查点镜像时会自动停止正在运行Java应用，但如Azul Prime ReadyNow、Spring-boot等支持按照周期等其它规则实现生成检查点镜像的同时不停止正在运行的Java应用，此功能也可用于生产环境。\n4.4.恢复 4.物理视图 略。","title":"CRaC:4+1视图架构简析"},{"content":"0.前言 0.1.Java程序执行过程 0.2.编译的快与慢 0.2.1.Java虚拟机（解释的（Interpreted）相对慢） 0.2.2.即时编译器（Just In Time Compiler）（相对快） 0.2.3.Java编译器（Java Compiler）（相对快） Eg: Graal编译器（既可以作为AOT编译器，又可以在JIT编译器中替换C2）、AOT（jaotc）\n1.JIT编译过程 Java应用启动后，在完成类加载、字节码验证后，并不会马上触发JIT编译器进行编译，而是先由即时解释器进行解释和分析； 即时解释器在完成了初步的解释和分析后，JIT编译器会利用已经收集到的分析信息来查找热点（经常执行的代码部分），有了热点代码后，C1就可以对这些热点代码进行分析，基于分析的结果编译生成相对高效的目标机器代码，从而使得此时的Java虚拟机具有本机的代码性能，于此同时C1也会进行进一步的分析； C1在完成了进一步的分析后，C2就会利用C1产生的分析信息，进行更积极、更耗时的优化，此时C2会重新编译代码，以生成更高效的目标机器代码，从而更明显的提升Java虚拟机的代码性能。 综上所述，基于热点的更多信息，C1 性能提升更快，而 C2 性能提升更好。 2.当前需求 Azul可以在模拟环境下预热（模拟出热点方法和循环体），然后将结果注入生产环境，直接使用 C2 编译，减少运行时的编译时间。这对于证券行业报盘等场景很有效，因为这些场景一开始就需要高速运转。\n横轴：JVM虚拟机达到最佳代码性能的时间； 纵轴：JVM最佳代码性能程度或比率； 毛刺：去优化和垃圾回收导致的。 3.问题 Azul可以在模拟环境中学习和训练，然后将训练结果集作为参考输入到生产环境中，以达到启动时的峰值效果。 并消除 GC毛刺。\n3.1.当前问题 启动时间长； 需要很长时间Java虚拟机才可以达到Java虚拟机的最佳代码性能。 3.2.期望结果 启动时间短； 启动后Java虚拟机可快速达到最佳代码性能。 3.3.期望目标 在保证关键功能正确使用的前提下，显著降低再次启动耗时； 消除毛刺，使得Java虚拟机快速达到最佳代码性能。 4.问题分析 4.1.现在加速启动的方案有哪些？ 4.1.1.CDS（Class Data Sharing,类数据共享） 功能定位： 将内部类、应用类、动态（自定义类加载器加载的类和省去dump classlist步骤）等表示转储到文件中（类加载器、jsa文件）； 在每个 JVM 启动时共享 (CDS)。\n不足： 没有优化或热点检测； 仅减少类加载时间； 启动速度加快不明显。\n4.1.2.AOT（Ahead Of Time Compilation，提前编译，源码到机器码） 优点： 从一开始就“全速”，GraalVM 原生镜像可以做到这一点; 根据定义，AOT 是静态的，代码在运行之前进行编译，运行时编译代码没有开销； 内存占用小\n不足： 不解释字节码； 没有热点分析； 没有代码的运行时编译，所以没有运行时字节码生成； 方法内联的有限使用； 反射是可能的，但很复杂； 无法使用推测性优化 （假设条件成立，如数组边界） 必须针对共同特征（如同名同参数等）进行编译 由于优化不彻底，所以总体性能通常会较低； 部署环境！=开发环境。\n4.1.3.JIT（Just In Time Compilation,即时编译） 优点： 可以在运行时使用激进的方法内联（如方法行数不超过80行，激进指大方法，编译时间长，产生大的二进制文件） 可以使用运行时字节码生成 反射很简单 可以使用推测性优化?（假设条件成立，如数组边界） 甚至可以针对 Haswell、Skylake、Ice Lake 等进行优化。（CPU架构） 总体性能通常会更高 部署环境 == 开发环境\n不足： 需要更多时间来启动（但会更快） 在运行时编译代码有开销 更大的内存占用\n4.2.为什么会产生毛刺（毛刺的存在直接影响Java虚拟机达到最佳性能）？ 4.2.1.存在去优化 尽管 C2 编译的代码经过高度优化且寿命较长，但它也可能会被取消优化。结果，JVM 将暂时回滚到解释状态。 当编译器的乐观假设被证明是错误的时，就会发生去优化 - 例如，当配置文件信息与方法行为不匹配时，一旦热路径发生变化，JVM 就会取消优化已编译和内联的代码。\n4.2.2.达到最佳性能前有GC操作 5.解决方案 5.1.(商用收费)Azul Prime ReadyNow 5.1.1.什么是Azul Prime ReadyNow? ReadyNow 是 Azul Platform Prime 的一项功能，启用后可显著改善应用程序的预热行为。\n5.1.2.什么是预热? 预热是指Java应用程序达到最佳性能所需的时间。实时（JIT）编译器的任务是通过从应用程序字节码生成优化的编译代码来提供最佳性能。这个过程需要一些时间，因为JIT编译器会根据应用程序的分析来寻找优化机会。\n5.1.3.基本思路 ReadyNow 会保留应用程序运行期间收集的分析信息，以便后续运行不必再次从头开始学习。预热可以改善每个应用程序的运行，直到达到最佳性能。\n5.1.4.使用方法 要启用 ReadyNow，请添加以下命令行选项，其中 通常对于两者来说是相同的： ● -XX:ProfileLogIn= 指示 Azul Platform Prime 使用现有配置文件日志中的信息。 ● -XX:ProfileLogOut= 记录先前的编译和运行中的去优化决策。 运行应用程序将自动生成或更新配置文件日志。此配置文件日志将在应用程序的后续运行时使用，从而改善预热。\n5.1.5.集成开发 闭源\n5.2.(开源免费)CRaC 5.2.1.什么是CRaC? Referenced to CRIU（Checkpoint Restore In Userspace,在用户空间的检查点恢复） CRaC（Coordinated Restore at Checkpoint,检查点协调恢复）项目研究 Java 程序与在执行时对 Java 实例进行检查点（制作镜像、快照）的机制的协调。 从映像恢复可以解决启动和预热时间方面的一些问题。 该项目的主要目标是开发一种新的与机制无关的标准 API，以通知 Java 程序有关检查点和恢复事件的信息。 其他研究活动将包括但不限于与现有检查点/恢复机制的集成以及新机制的开发、对 JVM 和 JDK 的更改以缩小镜像并确保它们是正确的。\n5.2.2.基本思路 向运行在特定（金丝雀）环境（CPU、内存、I/O、操作系统等）下的Java应用进行数据输入（模拟请求），当输入的数据达到饱和状态后（请求的路径覆盖了所有的用例），冻结正在运行的应用，将Java虚拟机达到最佳性能的检查点输出为快照文件进行留存，后续就可以通过先前保存的镜像文件启动应用（理论上可以是不同的物理机器）。\n5.2.3.部署流程 向运行在金丝雀环境的应用发起模拟请求，达到饱和请求后生成快照文件，然后在生产环境通过快照文件进行恢复应用。\n5.2.4.使用方法 要启用 CRaC，请添加以下命令行选项，其中 通常对于两者来说是相同的： ● -XX:CRaCRestoreFrom=cr 指示JDK使用现有配置文件日志中的信息。 ● -XX:CRaCCheckpointTo=cr 记录先前的编译和运行中的去优化决策。\n5.2.5.集成开发 5.2.5.1.获取源码 git clone https://github.com/openjdk/crac.git -b {tag} 5.2.5.2.手动编译 bash configure make images mv build/linux-x86_64-server-release/images/jdk/ . 5.2.5.3.下载兼容后的CRIU CRIU\n5.2.5.3.在JDK中的同一个命名文件上提取并复制criu二进制文件 cp criu-dist/sbin/criu jdk/lib/criu 5.2.5.4.执行授权 sudo chown root:root jdk/lib/criu sudo chmod u+s jdk/lib/criu 6.验证 6.1.官方验证 6.1.1.验证环境 笔记本电脑（Intel i7-5500U, 16Gb RAM and SSD.） 操作系统内核（Linux kernel 5.7.4-arch1-1） 操作系统（ubuntu:18.04 based image） 平台: archlinux\n6.1.2.验证场景 6.1.2.1.场景一：Time To First Operation 6.1.2.2.场景二：Time to Complete N operations:sprint-boot(OpenJDK ON/OFF CRaC) 6.1.2.3.场景三：Time to Complete N operations:quarkus(OpenJDK ON/OFF CRaC) 6.1.2.4.场景四：Time to Complete N operations:micronaut(OpenJDK ON/OFF CRaC) 6.2.本地验证 6.2.1.验证环境 笔记本（3.1 GHz Intel Core i5, 4Gb RAM and 50Gb SSD.） 操作系统内核（3.10.0-1160.102.1.el7.x86_64） 操作系统（CentOS:7.9 VM） 平台: x86_64 VM Parameters：除存放和加载镜像日志的参数外，没使用其它参数\n6.2.2.验证场景 6.2.2.1.场景一：Time Of First Operation 6.2.2.2.场景二：Time To Complete 100000 Operations ","permalink":"https://xiaotaonan.github.io/cn/posts/jit-warmstartup/","summary":"0.前言 0.1.Java程序执行过程 0.2.编译的快与慢 0.2.1.Java虚拟机（解释的（Interpreted）相对慢） 0.2.2.即时编译器（Just In Time Compiler）（相对快） 0.2.3.Java编译器（Java Compiler）（相对快） Eg: Graal编译器（既可以作为AOT编译器，又可以在JIT编译器中替换C2）、AOT（jaotc）\n1.JIT编译过程 Java应用启动后，在完成类加载、字节码验证后，并不会马上触发JIT编译器进行编译，而是先由即时解释器进行解释和分析； 即时解释器在完成了初步的解释和分析后，JIT编译器会利用已经收集到的分析信息来查找热点（经常执行的代码部分），有了热点代码后，C1就可以对这些热点代码进行分析，基于分析的结果编译生成相对高效的目标机器代码，从而使得此时的Java虚拟机具有本机的代码性能，于此同时C1也会进行进一步的分析； C1在完成了进一步的分析后，C2就会利用C1产生的分析信息，进行更积极、更耗时的优化，此时C2会重新编译代码，以生成更高效的目标机器代码，从而更明显的提升Java虚拟机的代码性能。 综上所述，基于热点的更多信息，C1 性能提升更快，而 C2 性能提升更好。 2.当前需求 Azul可以在模拟环境下预热（模拟出热点方法和循环体），然后将结果注入生产环境，直接使用 C2 编译，减少运行时的编译时间。这对于证券行业报盘等场景很有效，因为这些场景一开始就需要高速运转。\n横轴：JVM虚拟机达到最佳代码性能的时间； 纵轴：JVM最佳代码性能程度或比率； 毛刺：去优化和垃圾回收导致的。 3.问题 Azul可以在模拟环境中学习和训练，然后将训练结果集作为参考输入到生产环境中，以达到启动时的峰值效果。 并消除 GC毛刺。\n3.1.当前问题 启动时间长； 需要很长时间Java虚拟机才可以达到Java虚拟机的最佳代码性能。 3.2.期望结果 启动时间短； 启动后Java虚拟机可快速达到最佳代码性能。 3.3.期望目标 在保证关键功能正确使用的前提下，显著降低再次启动耗时； 消除毛刺，使得Java虚拟机快速达到最佳代码性能。 4.问题分析 4.1.现在加速启动的方案有哪些？ 4.1.1.CDS（Class Data Sharing,类数据共享） 功能定位： 将内部类、应用类、动态（自定义类加载器加载的类和省去dump classlist步骤）等表示转储到文件中（类加载器、jsa文件）； 在每个 JVM 启动时共享 (CDS)。\n不足： 没有优化或热点检测； 仅减少类加载时间； 启动速度加快不明显。\n4.1.2.AOT（Ahead Of Time Compilation，提前编译，源码到机器码） 优点： 从一开始就“全速”，GraalVM 原生镜像可以做到这一点; 根据定义，AOT 是静态的，代码在运行之前进行编译，运行时编译代码没有开销； 内存占用小\n不足： 不解释字节码； 没有热点分析； 没有代码的运行时编译，所以没有运行时字节码生成； 方法内联的有限使用； 反射是可能的，但很复杂； 无法使用推测性优化 （假设条件成立，如数组边界） 必须针对共同特征（如同名同参数等）进行编译 由于优化不彻底，所以总体性能通常会较低； 部署环境！=开发环境。","title":"JIT启动预热"}]